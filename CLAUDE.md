# CLAUDE.md — Auto-generated by Riker

<!-- Do not edit manually. Managed by Riker rule sync. -->

## Git Workflow & Branch Safety

> Category: git_workflow | Version: 2

# Git Workflow & Branch Safety

## Branch Strategy
- **Work on `development`** (or feature branches off it) — never commit directly to `main`
- Before starting work, verify branch: `git branch --show-current`
- If on `main`, switch immediately: `git checkout development`

## Commit & Push
- Commit at logical checkpoints (completed checklist items, features, fixes)
- Message format: `feat(scope): description`, `fix(scope): description`
- Push to `development` or feature branch — never `git push origin main`
- Never commit half-working OAuth flows, broken migrations, or untested code

## Merging to Production
- All merges to `main` happen via **GitHub Pull Requests only**
- PR must pass CI checks and be reviewed before merge
- After merge, sync development: `git checkout development && git pull origin main`

## GitHub Repository Setup
- **Branch protection on `main`**: require PR reviews, require status checks, no bypass
- **Default branch**: set to `development` so clones start on the right branch

## Nexus Stage Template for Development Projects

```
1. Planning & Setup        — requirements, tech spec, environment, branch verification
2. Development             — implementation, self-review, unit tests
3. Testing & QA            — functional testing, integration, edge cases (manual verification)
4. Deployment Preparation  — create PR, code review, CI checks, merge to main
5. Deployment & Monitoring — production deploy, smoke test, verify logs
```

Each stage should have checklist items tracked in Nexus. The QA stage requires manual sign-off before proceeding to deployment.

## Claude Code Integration
When executing commands from Nexus:
1. Verify branch (switch to `development` if needed)
2. Pull latest changes
3. Implement and test
4. Commit and push to `development`
5. Mark Nexus checklist items complete
6. Add stage notes for context


---

## Workflow Orchestration & Knowledge Management

> Category: architecture_decisions | Version: 2

# Workflow Orchestration & Knowledge Management

These rules govern how Claude operates across all Nexus-tracked projects. They enforce disciplined planning, continuous learning via the Nexus knowledge base and external sources, and verification-first delivery.

---

## 1. Plan First, Always

Enter plan mode for ANY non-trivial task (3+ steps or architectural decisions).

- **Before coding**: write the plan as a Nexus stage checklist or task subtasks — never in throwaway local files
- **If something goes sideways**: STOP and re-plan immediately — don't keep pushing down a broken path
- **Use plan mode for verification steps**, not just building
- **Write detailed specs upfront** to reduce ambiguity — use `createScratchpad` for cross-session design notes

## 2. Subagent Strategy

Use subagents liberally to keep the main context window clean.

- Offload research, exploration, and parallel analysis to subagents
- For complex problems, throw more compute at it via parallel subagents
- One focused task per subagent for clear execution
- Never duplicate work that a subagent is already doing

## 3. Search Broadly, Store Locally

Before starting any task, search everywhere — not just Nexus.

### Layer 1: Nexus Knowledge Base (instant, free)
- `searchKnowledge` for lessons, snippets, decisions, playbooks
- `listAgentLearnings` for relevant category patterns
- `searchErrorPlaybook` and `suggestFix` for known error resolutions

### Layer 2: Web and Documentation (when Nexus KB has no answer)
- Use web search for current best practices, library docs, API references
- Check official documentation for frameworks in the tech stack
- Search GitHub issues for known bugs or workarounds

### Layer 3: Capture Back Into Nexus
This is the critical step. When external research yields a useful answer:
- Reusable solution → `saveSnippet` with language, tags, and tech_stack
- Best practice or pattern → `captureLesson` with category "pattern" or "insight"
- Multi-step procedure → `createPlaybook` with tech_stack_tags for auto-matching
- Error fix → `createErrorPlaybook` so it is instant next time
- Architectural guidance → `logDecision` with reasoning and alternatives

The goal: every external lookup should only happen once. After that, the answer lives in Nexus for all projects.

## 4. Self-Improvement Loop

After ANY correction from the user or significant learning moment, capture it in the right Nexus tool and always assess scope.

### Scope Assessment (every time)
Ask: "Is this specific to this project, or useful across projects?"
- **Project-specific** → include project_id, use scope "project" for error playbooks
- **Platform-wide** (e.g. all Node projects) → tag with platform, use scope "platform"
- **Universal** → omit project_id, use scope "global", broad tags

### Corrections and Patterns → Agent Learnings
For mistakes caught by the user or patterns from repeated work, use `addAgentLearning` with lesson_type (user_correction, failure_pattern, success_pattern), a specific actionable pattern, category, confidence score, and context for when it applies.

### Broader Insights → Lessons Learned
For insights, workarounds, or mistakes worth sharing across sessions, use `captureLesson` with title, detailed description, category (insight, mistake, pattern, decision, workaround), source "claude_session", and appropriate tags.

### Architecture Decisions → Decision Log
When making significant technical choices, use `logDecision` with title, decision, reasoning (including evidence gathered), and alternatives_considered.

### Reusable Code → Snippets
When writing or discovering reusable code, use `saveSnippet` with title, language, code, tags, and tech_stack. Omit project_id for universal snippets.

### Recurring Procedures → Playbooks
When a multi-step procedure should be standardised, use `createPlaybook` with title, markdown content, category, and tech_stack_tags for auto-matching.

### Error Resolutions → Error Playbooks
When fixing a bug worth documenting, use `createErrorPlaybook` with fingerprint, title, fix_steps, platform, and scope. When a project-level fix proves universal, use `promoteErrorPlaybook` to escalate scope.

### Cross-Session Notes → Scratchpads
For work-in-progress context that future sessions need, use `createScratchpad` with project_id, title, and content describing what the next session needs to know.

## 5. Session Rituals

### Session Start — Orient Before Acting
Before writing any code in a new session:
1. `searchKnowledge` for the task description — what do we already know?
2. `listAgentLearnings` for relevant category — any corrections to remember?
3. Check project scratchpads — any handoff notes from previous sessions?
4. `getRecentAgentJournal` — what happened recently?

### Session End — Capture Before Closing
Before ending significant work:
1. `addAgentJournalEntry` — summarise what was done, what is left, any blockers
2. Capture any uncaptured learnings (corrections, patterns, insights)
3. Update scratchpads if there is unfinished work for the next session
4. `captureWorkSession` — log the work block against the project

## 6. Knowledge Hygiene

### Deduplication
Always `searchKnowledge` before creating new entries. Update existing knowledge rather than creating duplicates.

### Confidence Management
- When an agent learning proves correct repeatedly → boost confidence with `updateLearningConfidence`
- When a learning is contradicted by new evidence → reduce confidence or remove it
- High-confidence learnings (0.9+) are candidates for promotion to Claude Rules

### Playbook Versioning
When a playbook's steps change due to new learnings, use `updatePlaybook` — it auto-increments the version and snapshots the old one.

### Promotion Pipeline
Project fix → Error Playbook (project scope) → Proves universal → promoteErrorPlaybook (platform/global) → Pattern solidifies → createPlaybook (standardised procedure) → Rule-worthy → Promote to Claude Rule

## 7. Verification Before Done

Never mark a task complete without proving it works.

- Run tests, check logs, demonstrate correctness
- Diff behaviour between main and your changes when relevant
- Ask yourself: "Would a staff engineer approve this?"
- Log verification with `addAgentJournalEntry` using entry_type "quality_check"

## 8. Demand Elegance (Balanced)

For non-trivial changes: pause and ask "is there a more elegant way?"

- If a fix feels hacky, step back and implement the proper solution
- Skip this for simple, obvious fixes — don't over-engineer
- Challenge your own work before presenting it
- When an elegant pattern emerges, capture it with `addAgentLearning` as a success_pattern

## 9. Autonomous Bug Fixing

When given a bug report: just fix it. Don't ask for hand-holding.

1. Check `suggestFix` / `searchErrorPlaybook` — have we seen this before?
2. If no playbook exists: investigate, diagnose, fix
3. After fixing: `createErrorPlaybook` so it is instant next time
4. Zero context switching required from the user

## 10. Task Management via Nexus

- **Plan**: Write plans as Nexus stage checklists or task subtasks
- **Track Progress**: Mark items complete as you go (always use batch operations)
- **Explain Changes**: High-level summary at each step
- **Stage Notes**: Add context with `addStageNote` for future sessions
- **Work Sessions**: Use `captureWorkSession` at the end of significant blocks

## 11. The Knowledge Flywheel

This is the core loop. Every session makes the system smarter.

Session Start: Orient with searchKnowledge, listAgentLearnings, check scratchpads. Plan with stage checklists or task subtasks.

During Work:
- Known problem → suggestFix / searchErrorPlaybook (instant resolution)
- Unknown problem → web search, fix, then createErrorPlaybook (never look it up again)
- User corrects me → addAgentLearning immediately (never repeat the mistake)
- Discovered best practice → captureLesson (all projects benefit)
- Made architectural choice → logDecision (reasoning preserved)
- Wrote reusable code → saveSnippet (ready for next project)
- Built repeatable procedure → createPlaybook (standardised forever)
- Fix proved universal → promoteErrorPlaybook (scope escalation)

Session End: Journal summary, capture uncaptured learnings, update scratchpads.

## 12. Core Principles

- **Simplicity First**: Make every change as simple as possible. Minimal code impact.
- **No Laziness**: Find root causes. No temporary fixes. Senior developer standards.
- **Minimal Impact**: Changes should only touch what's necessary. Avoid introducing bugs.
- **Security Always**: No hardcoded secrets, no plaintext credentials, proper auth everywhere.
- **Knowledge Compounds**: If you learned it, log it. If you built it, document it. If it broke, playbook it. If it is universal, promote it.
- **Search Before You Solve**: The answer might already exist — in Nexus, on the web, or in documentation. Don't re-derive what is already known.


---

